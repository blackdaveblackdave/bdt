"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_thirdweb_dist_esm_wallets_injected_index_js"],{

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/wallets/injected/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/wallets/injected/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoConnectInjectedWallet: function() { return /* binding */ autoConnectInjectedWallet; },\n/* harmony export */   connectInjectedWallet: function() { return /* binding */ connectInjectedWallet; },\n/* harmony export */   getInjectedProvider: function() { return /* binding */ getInjectedProvider; }\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/typedData.js\");\n/* harmony import */ var _chains_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../chains/utils.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/chains/utils.js\");\n/* harmony import */ var _utils_address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/address.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/address.js\");\n/* harmony import */ var _utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/encoding/hex.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/encoding/hex.js\");\n/* harmony import */ var _utils_signatures_helpers_parseTypedData_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/signatures/helpers/parseTypedData.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/signatures/helpers/parseTypedData.js\");\n/* harmony import */ var _utils_chains_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/chains.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/wallets/utils/chains.js\");\n/* harmony import */ var _utils_normalizeChainId_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/normalizeChainId.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/wallets/utils/normalizeChainId.js\");\n/* harmony import */ var _mipdStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mipdStore.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/wallets/injected/mipdStore.js\");\n\n\n\n\n\n\n\n\n// TODO: save the provider in data\nfunction getInjectedProvider(walletId) {\n    const provider = (0,_mipdStore_js__WEBPACK_IMPORTED_MODULE_0__.injectedProvider)(walletId);\n    if (!provider) {\n        throw new Error(`No injected provider found for wallet: \"${walletId}\"`);\n    }\n    return provider;\n}\n/**\n * @internal\n */\nasync function connectInjectedWallet(id, options, emitter) {\n    const provider = getInjectedProvider(id);\n    const addresses = await provider.request({\n        method: \"eth_requestAccounts\",\n    });\n    const addr = addresses[0];\n    if (!addr) {\n        throw new Error(\"no accounts available\");\n    }\n    // use the first account\n    const address = (0,_utils_address_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(addr);\n    // get the chainId the provider is on\n    const chainId = await provider\n        .request({ method: \"eth_chainId\" })\n        .then(_utils_normalizeChainId_js__WEBPACK_IMPORTED_MODULE_2__.normalizeChainId);\n    let connectedChain = options.chain && options.chain.id === chainId\n        ? options.chain\n        : (0,_chains_utils_js__WEBPACK_IMPORTED_MODULE_3__.getCachedChain)(chainId);\n    // if we want a specific chainId and it is not the same as the provider chainId, trigger switchChain\n    if (options.chain && options.chain.id !== chainId) {\n        await switchChain(provider, options.chain);\n        connectedChain = options.chain;\n    }\n    return onConnect(provider, address, connectedChain, emitter);\n}\n/**\n * @internal\n */\nasync function autoConnectInjectedWallet(id, emitter, chain) {\n    const provider = getInjectedProvider(id);\n    // connected accounts\n    const addresses = await provider.request({\n        method: \"eth_accounts\",\n    });\n    const addr = addresses[0];\n    if (!addr) {\n        throw new Error(\"no accounts available\");\n    }\n    // use the first account\n    const address = (0,_utils_address_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(addr);\n    // get the chainId the provider is on\n    const chainId = await provider\n        .request({ method: \"eth_chainId\" })\n        .then(_utils_normalizeChainId_js__WEBPACK_IMPORTED_MODULE_2__.normalizeChainId);\n    const connectedChain = chain && chain.id === chainId ? chain : (0,_chains_utils_js__WEBPACK_IMPORTED_MODULE_3__.getCachedChain)(chainId);\n    return onConnect(provider, address, connectedChain, emitter);\n}\nfunction createAccount(provider, _address) {\n    const account = {\n        address: (0,_utils_address_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(_address),\n        async sendTransaction(tx) {\n            const transactionHash = (await provider.request({\n                method: \"eth_sendTransaction\",\n                params: [\n                    {\n                        accessList: tx.accessList,\n                        value: tx.value ? (0,_utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.numberToHex)(tx.value) : undefined,\n                        gas: tx.gas ? (0,_utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.numberToHex)(tx.gas) : undefined,\n                        from: this.address,\n                        to: tx.to,\n                        data: tx.data,\n                    },\n                ],\n            }));\n            return {\n                transactionHash,\n            };\n        },\n        async signMessage({ message }) {\n            if (!account.address) {\n                throw new Error(\"Provider not setup\");\n            }\n            const messageToSign = (() => {\n                if (typeof message === \"string\") {\n                    return (0,_utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.stringToHex)(message);\n                }\n                if (message.raw instanceof Uint8Array) {\n                    return (0,_utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.uint8ArrayToHex)(message.raw);\n                }\n                return message.raw;\n            })();\n            return await provider.request({\n                method: \"personal_sign\",\n                params: [messageToSign, account.address],\n            });\n        },\n        async signTypedData(typedData) {\n            if (!provider || !account.address) {\n                throw new Error(\"Provider not setup\");\n            }\n            const parsedTypedData = (0,_utils_signatures_helpers_parseTypedData_js__WEBPACK_IMPORTED_MODULE_5__.parseTypedData)(typedData);\n            const { domain, message, primaryType } = parsedTypedData;\n            const types = {\n                EIP712Domain: (0,viem__WEBPACK_IMPORTED_MODULE_6__.getTypesForEIP712Domain)({ domain }),\n                ...parsedTypedData.types,\n            };\n            // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n            // as we can't statically check this with TypeScript.\n            (0,viem__WEBPACK_IMPORTED_MODULE_6__.validateTypedData)({ domain, message, primaryType, types });\n            const stringifiedData = (0,viem__WEBPACK_IMPORTED_MODULE_6__.serializeTypedData)({\n                domain: domain ?? {},\n                message,\n                primaryType,\n                types,\n            });\n            return await provider.request({\n                method: \"eth_signTypedData_v4\",\n                params: [account.address, stringifiedData],\n            });\n        },\n        async watchAsset(asset) {\n            const result = await provider.request({\n                method: \"wallet_watchAsset\",\n                params: asset,\n            }, { retryCount: 0 });\n            return result;\n        },\n    };\n    return account;\n}\n/**\n * Call this method when the wallet provider is connected or auto connected\n * @internal\n */\nasync function onConnect(provider, address, chain, emitter) {\n    const account = createAccount(provider, address);\n    async function disconnect() {\n        provider.removeListener(\"accountsChanged\", onAccountsChanged);\n        provider.removeListener(\"chainChanged\", onChainChanged);\n        provider.removeListener(\"disconnect\", onDisconnect);\n    }\n    async function onDisconnect() {\n        disconnect();\n        emitter.emit(\"disconnect\", undefined);\n    }\n    function onAccountsChanged(accounts) {\n        if (accounts[0]) {\n            const newAccount = createAccount(provider, (0,_utils_address_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(accounts[0]));\n            emitter.emit(\"accountChanged\", newAccount);\n            emitter.emit(\"accountsChanged\", accounts);\n        }\n        else {\n            onDisconnect();\n        }\n    }\n    function onChainChanged(newChainId) {\n        const newChain = (0,_chains_utils_js__WEBPACK_IMPORTED_MODULE_3__.getCachedChain)((0,_utils_normalizeChainId_js__WEBPACK_IMPORTED_MODULE_2__.normalizeChainId)(newChainId));\n        emitter.emit(\"chainChanged\", newChain);\n    }\n    if (provider.on) {\n        provider.on(\"accountsChanged\", onAccountsChanged);\n        provider.on(\"chainChanged\", onChainChanged);\n        provider.on(\"disconnect\", onDisconnect);\n    }\n    return [\n        account,\n        chain,\n        onDisconnect,\n        (newChain) => switchChain(provider, newChain),\n    ];\n}\n/**\n * @internal\n */\nasync function switchChain(provider, chain) {\n    const hexChainId = (0,_utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.numberToHex)(chain.id);\n    try {\n        await provider.request({\n            method: \"wallet_switchEthereumChain\",\n            params: [{ chainId: hexChainId }],\n        });\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n    }\n    catch (e) {\n        // if chain does not exist, add the chain\n        if (e?.code === 4902 || e?.data?.originalError?.code === 4902) {\n            const apiChain = await (0,_chains_utils_js__WEBPACK_IMPORTED_MODULE_3__.getChainMetadata)(chain);\n            await provider.request({\n                method: \"wallet_addEthereumChain\",\n                params: [\n                    {\n                        chainId: hexChainId,\n                        chainName: apiChain.name,\n                        nativeCurrency: apiChain.nativeCurrency,\n                        rpcUrls: (0,_utils_chains_js__WEBPACK_IMPORTED_MODULE_7__.getValidPublicRPCUrl)(apiChain), // no client id on purpose here\n                        blockExplorerUrls: apiChain.explorers?.map((x) => x.url),\n                    },\n                ],\n            });\n        }\n        else {\n            throw e;\n        }\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS93YWxsZXRzL2luamVjdGVkL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXVGO0FBQ2Q7QUFDckI7QUFDcUM7QUFDUDtBQUN4QjtBQUNNO0FBQ2Q7QUFDbEQ7QUFDTztBQUNQLHFCQUFxQiwrREFBZ0I7QUFDckM7QUFDQSxtRUFBbUUsU0FBUztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZEQUFVO0FBQzlCO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDLGNBQWMsd0VBQWdCO0FBQzlCO0FBQ0E7QUFDQSxVQUFVLGdFQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZEQUFVO0FBQzlCO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDLGNBQWMsd0VBQWdCO0FBQzlCLG1FQUFtRSxnRUFBYztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2REFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUVBQVc7QUFDckQsc0NBQXNDLG1FQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtRUFBVztBQUN0QztBQUNBO0FBQ0EsMkJBQTJCLHVFQUFlO0FBQzFDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyRkFBYztBQUNsRCxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0EsOEJBQThCLDZEQUF1QixHQUFHLFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVEQUFpQixHQUFHLHFDQUFxQztBQUNyRSxvQ0FBb0Msd0RBQWtCO0FBQ3RELG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSSxlQUFlO0FBQ2hDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsNkRBQVU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnRUFBYyxDQUFDLDRFQUFnQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUVBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrRUFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0VBQW9CO0FBQ3JEO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS93YWxsZXRzL2luamVjdGVkL2luZGV4LmpzPzBhNTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0VHlwZXNGb3JFSVA3MTJEb21haW4sIHNlcmlhbGl6ZVR5cGVkRGF0YSwgdmFsaWRhdGVUeXBlZERhdGEsIH0gZnJvbSBcInZpZW1cIjtcbmltcG9ydCB7IGdldENhY2hlZENoYWluLCBnZXRDaGFpbk1ldGFkYXRhIH0gZnJvbSBcIi4uLy4uL2NoYWlucy91dGlscy5qc1wiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi8uLi91dGlscy9hZGRyZXNzLmpzXCI7XG5pbXBvcnQgeyBudW1iZXJUb0hleCwgc3RyaW5nVG9IZXgsIHVpbnQ4QXJyYXlUb0hleCwgfSBmcm9tIFwiLi4vLi4vdXRpbHMvZW5jb2RpbmcvaGV4LmpzXCI7XG5pbXBvcnQgeyBwYXJzZVR5cGVkRGF0YSB9IGZyb20gXCIuLi8uLi91dGlscy9zaWduYXR1cmVzL2hlbHBlcnMvcGFyc2VUeXBlZERhdGEuanNcIjtcbmltcG9ydCB7IGdldFZhbGlkUHVibGljUlBDVXJsIH0gZnJvbSBcIi4uL3V0aWxzL2NoYWlucy5qc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplQ2hhaW5JZCB9IGZyb20gXCIuLi91dGlscy9ub3JtYWxpemVDaGFpbklkLmpzXCI7XG5pbXBvcnQgeyBpbmplY3RlZFByb3ZpZGVyIH0gZnJvbSBcIi4vbWlwZFN0b3JlLmpzXCI7XG4vLyBUT0RPOiBzYXZlIHRoZSBwcm92aWRlciBpbiBkYXRhXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5qZWN0ZWRQcm92aWRlcih3YWxsZXRJZCkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gaW5qZWN0ZWRQcm92aWRlcih3YWxsZXRJZCk7XG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGluamVjdGVkIHByb3ZpZGVyIGZvdW5kIGZvciB3YWxsZXQ6IFwiJHt3YWxsZXRJZH1cImApO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdmlkZXI7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29ubmVjdEluamVjdGVkV2FsbGV0KGlkLCBvcHRpb25zLCBlbWl0dGVyKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBnZXRJbmplY3RlZFByb3ZpZGVyKGlkKTtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiBcImV0aF9yZXF1ZXN0QWNjb3VudHNcIixcbiAgICB9KTtcbiAgICBjb25zdCBhZGRyID0gYWRkcmVzc2VzWzBdO1xuICAgIGlmICghYWRkcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBhY2NvdW50cyBhdmFpbGFibGVcIik7XG4gICAgfVxuICAgIC8vIHVzZSB0aGUgZmlyc3QgYWNjb3VudFxuICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRBZGRyZXNzKGFkZHIpO1xuICAgIC8vIGdldCB0aGUgY2hhaW5JZCB0aGUgcHJvdmlkZXIgaXMgb25cbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgcHJvdmlkZXJcbiAgICAgICAgLnJlcXVlc3QoeyBtZXRob2Q6IFwiZXRoX2NoYWluSWRcIiB9KVxuICAgICAgICAudGhlbihub3JtYWxpemVDaGFpbklkKTtcbiAgICBsZXQgY29ubmVjdGVkQ2hhaW4gPSBvcHRpb25zLmNoYWluICYmIG9wdGlvbnMuY2hhaW4uaWQgPT09IGNoYWluSWRcbiAgICAgICAgPyBvcHRpb25zLmNoYWluXG4gICAgICAgIDogZ2V0Q2FjaGVkQ2hhaW4oY2hhaW5JZCk7XG4gICAgLy8gaWYgd2Ugd2FudCBhIHNwZWNpZmljIGNoYWluSWQgYW5kIGl0IGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgcHJvdmlkZXIgY2hhaW5JZCwgdHJpZ2dlciBzd2l0Y2hDaGFpblxuICAgIGlmIChvcHRpb25zLmNoYWluICYmIG9wdGlvbnMuY2hhaW4uaWQgIT09IGNoYWluSWQpIHtcbiAgICAgICAgYXdhaXQgc3dpdGNoQ2hhaW4ocHJvdmlkZXIsIG9wdGlvbnMuY2hhaW4pO1xuICAgICAgICBjb25uZWN0ZWRDaGFpbiA9IG9wdGlvbnMuY2hhaW47XG4gICAgfVxuICAgIHJldHVybiBvbkNvbm5lY3QocHJvdmlkZXIsIGFkZHJlc3MsIGNvbm5lY3RlZENoYWluLCBlbWl0dGVyKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhdXRvQ29ubmVjdEluamVjdGVkV2FsbGV0KGlkLCBlbWl0dGVyLCBjaGFpbikge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0SW5qZWN0ZWRQcm92aWRlcihpZCk7XG4gICAgLy8gY29ubmVjdGVkIGFjY291bnRzXG4gICAgY29uc3QgYWRkcmVzc2VzID0gYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogXCJldGhfYWNjb3VudHNcIixcbiAgICB9KTtcbiAgICBjb25zdCBhZGRyID0gYWRkcmVzc2VzWzBdO1xuICAgIGlmICghYWRkcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBhY2NvdW50cyBhdmFpbGFibGVcIik7XG4gICAgfVxuICAgIC8vIHVzZSB0aGUgZmlyc3QgYWNjb3VudFxuICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRBZGRyZXNzKGFkZHIpO1xuICAgIC8vIGdldCB0aGUgY2hhaW5JZCB0aGUgcHJvdmlkZXIgaXMgb25cbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgcHJvdmlkZXJcbiAgICAgICAgLnJlcXVlc3QoeyBtZXRob2Q6IFwiZXRoX2NoYWluSWRcIiB9KVxuICAgICAgICAudGhlbihub3JtYWxpemVDaGFpbklkKTtcbiAgICBjb25zdCBjb25uZWN0ZWRDaGFpbiA9IGNoYWluICYmIGNoYWluLmlkID09PSBjaGFpbklkID8gY2hhaW4gOiBnZXRDYWNoZWRDaGFpbihjaGFpbklkKTtcbiAgICByZXR1cm4gb25Db25uZWN0KHByb3ZpZGVyLCBhZGRyZXNzLCBjb25uZWN0ZWRDaGFpbiwgZW1pdHRlcik7XG59XG5mdW5jdGlvbiBjcmVhdGVBY2NvdW50KHByb3ZpZGVyLCBfYWRkcmVzcykge1xuICAgIGNvbnN0IGFjY291bnQgPSB7XG4gICAgICAgIGFkZHJlc3M6IGdldEFkZHJlc3MoX2FkZHJlc3MpLFxuICAgICAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaCA9IChhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NMaXN0OiB0eC5hY2Nlc3NMaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHR4LnZhbHVlID8gbnVtYmVyVG9IZXgodHgudmFsdWUpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FzOiB0eC5nYXMgPyBudW1iZXJUb0hleCh0eC5nYXMpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IHR4LnRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBzaWduTWVzc2FnZSh7IG1lc3NhZ2UgfSkge1xuICAgICAgICAgICAgaWYgKCFhY2NvdW50LmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBub3Qgc2V0dXBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlVG9TaWduID0gKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1RvSGV4KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5yYXcgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1aW50OEFycmF5VG9IZXgobWVzc2FnZS5yYXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZS5yYXc7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJwZXJzb25hbF9zaWduXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbbWVzc2FnZVRvU2lnbiwgYWNjb3VudC5hZGRyZXNzXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBzaWduVHlwZWREYXRhKHR5cGVkRGF0YSkge1xuICAgICAgICAgICAgaWYgKCFwcm92aWRlciB8fCAhYWNjb3VudC5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgbm90IHNldHVwXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyc2VkVHlwZWREYXRhID0gcGFyc2VUeXBlZERhdGEodHlwZWREYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9tYWluLCBtZXNzYWdlLCBwcmltYXJ5VHlwZSB9ID0gcGFyc2VkVHlwZWREYXRhO1xuICAgICAgICAgICAgY29uc3QgdHlwZXMgPSB7XG4gICAgICAgICAgICAgICAgRUlQNzEyRG9tYWluOiBnZXRUeXBlc0ZvckVJUDcxMkRvbWFpbih7IGRvbWFpbiB9KSxcbiAgICAgICAgICAgICAgICAuLi5wYXJzZWRUeXBlZERhdGEudHlwZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gTmVlZCB0byBkbyBhIHJ1bnRpbWUgdmFsaWRhdGlvbiBjaGVjayBvbiBhZGRyZXNzZXMsIGJ5dGUgcmFuZ2VzLCBpbnRlZ2VyIHJhbmdlcywgZXRjXG4gICAgICAgICAgICAvLyBhcyB3ZSBjYW4ndCBzdGF0aWNhbGx5IGNoZWNrIHRoaXMgd2l0aCBUeXBlU2NyaXB0LlxuICAgICAgICAgICAgdmFsaWRhdGVUeXBlZERhdGEoeyBkb21haW4sIG1lc3NhZ2UsIHByaW1hcnlUeXBlLCB0eXBlcyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkRGF0YSA9IHNlcmlhbGl6ZVR5cGVkRGF0YSh7XG4gICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4gPz8ge30sXG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBwcmltYXJ5VHlwZSxcbiAgICAgICAgICAgICAgICB0eXBlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfc2lnblR5cGVkRGF0YV92NFwiLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW2FjY291bnQuYWRkcmVzcywgc3RyaW5naWZpZWREYXRhXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyB3YXRjaEFzc2V0KGFzc2V0KSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwid2FsbGV0X3dhdGNoQXNzZXRcIixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IGFzc2V0LFxuICAgICAgICAgICAgfSwgeyByZXRyeUNvdW50OiAwIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBhY2NvdW50O1xufVxuLyoqXG4gKiBDYWxsIHRoaXMgbWV0aG9kIHdoZW4gdGhlIHdhbGxldCBwcm92aWRlciBpcyBjb25uZWN0ZWQgb3IgYXV0byBjb25uZWN0ZWRcbiAqIEBpbnRlcm5hbFxuICovXG5hc3luYyBmdW5jdGlvbiBvbkNvbm5lY3QocHJvdmlkZXIsIGFkZHJlc3MsIGNoYWluLCBlbWl0dGVyKSB7XG4gICAgY29uc3QgYWNjb3VudCA9IGNyZWF0ZUFjY291bnQocHJvdmlkZXIsIGFkZHJlc3MpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKFwiYWNjb3VudHNDaGFuZ2VkXCIsIG9uQWNjb3VudHNDaGFuZ2VkKTtcbiAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoXCJjaGFpbkNoYW5nZWRcIiwgb25DaGFpbkNoYW5nZWQpO1xuICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcihcImRpc2Nvbm5lY3RcIiwgb25EaXNjb25uZWN0KTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gb25EaXNjb25uZWN0KCkge1xuICAgICAgICBkaXNjb25uZWN0KCk7XG4gICAgICAgIGVtaXR0ZXIuZW1pdChcImRpc2Nvbm5lY3RcIiwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25BY2NvdW50c0NoYW5nZWQoYWNjb3VudHMpIHtcbiAgICAgICAgaWYgKGFjY291bnRzWzBdKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdBY2NvdW50ID0gY3JlYXRlQWNjb3VudChwcm92aWRlciwgZ2V0QWRkcmVzcyhhY2NvdW50c1swXSkpO1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0KFwiYWNjb3VudENoYW5nZWRcIiwgbmV3QWNjb3VudCk7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoXCJhY2NvdW50c0NoYW5nZWRcIiwgYWNjb3VudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb25EaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25DaGFpbkNoYW5nZWQobmV3Q2hhaW5JZCkge1xuICAgICAgICBjb25zdCBuZXdDaGFpbiA9IGdldENhY2hlZENoYWluKG5vcm1hbGl6ZUNoYWluSWQobmV3Q2hhaW5JZCkpO1xuICAgICAgICBlbWl0dGVyLmVtaXQoXCJjaGFpbkNoYW5nZWRcIiwgbmV3Q2hhaW4pO1xuICAgIH1cbiAgICBpZiAocHJvdmlkZXIub24pIHtcbiAgICAgICAgcHJvdmlkZXIub24oXCJhY2NvdW50c0NoYW5nZWRcIiwgb25BY2NvdW50c0NoYW5nZWQpO1xuICAgICAgICBwcm92aWRlci5vbihcImNoYWluQ2hhbmdlZFwiLCBvbkNoYWluQ2hhbmdlZCk7XG4gICAgICAgIHByb3ZpZGVyLm9uKFwiZGlzY29ubmVjdFwiLCBvbkRpc2Nvbm5lY3QpO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICBhY2NvdW50LFxuICAgICAgICBjaGFpbixcbiAgICAgICAgb25EaXNjb25uZWN0LFxuICAgICAgICAobmV3Q2hhaW4pID0+IHN3aXRjaENoYWluKHByb3ZpZGVyLCBuZXdDaGFpbiksXG4gICAgXTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN3aXRjaENoYWluKHByb3ZpZGVyLCBjaGFpbikge1xuICAgIGNvbnN0IGhleENoYWluSWQgPSBudW1iZXJUb0hleChjaGFpbi5pZCk7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICBtZXRob2Q6IFwid2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW5cIixcbiAgICAgICAgICAgIHBhcmFtczogW3sgY2hhaW5JZDogaGV4Q2hhaW5JZCB9XSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9FeHBsaWNpdEFueTogVE9ETzogZml4IGFueVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpZiBjaGFpbiBkb2VzIG5vdCBleGlzdCwgYWRkIHRoZSBjaGFpblxuICAgICAgICBpZiAoZT8uY29kZSA9PT0gNDkwMiB8fCBlPy5kYXRhPy5vcmlnaW5hbEVycm9yPy5jb2RlID09PSA0OTAyKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlDaGFpbiA9IGF3YWl0IGdldENoYWluTWV0YWRhdGEoY2hhaW4pO1xuICAgICAgICAgICAgYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIndhbGxldF9hZGRFdGhlcmV1bUNoYWluXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IGhleENoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbk5hbWU6IGFwaUNoYWluLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVDdXJyZW5jeTogYXBpQ2hhaW4ubmF0aXZlQ3VycmVuY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICBycGNVcmxzOiBnZXRWYWxpZFB1YmxpY1JQQ1VybChhcGlDaGFpbiksIC8vIG5vIGNsaWVudCBpZCBvbiBwdXJwb3NlIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrRXhwbG9yZXJVcmxzOiBhcGlDaGFpbi5leHBsb3JlcnM/Lm1hcCgoeCkgPT4geC51cmwpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/wallets/injected/index.js\n"));

/***/ })

}]);